{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Within starlette-core we set-up the base functionality of a Starlette project. This provides the core of a modular project and includes the implementation of a database, pagination and email functionality which can then be utilised by additional modules as the project expands. Getting Started - Installation This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-core.git@master#egg=starlette-core The minimum Python requirement is 3.7.","title":"Introduction"},{"location":"#introduction","text":"Within starlette-core we set-up the base functionality of a Starlette project. This provides the core of a modular project and includes the implementation of a database, pagination and email functionality which can then be utilised by additional modules as the project expands.","title":"Introduction"},{"location":"#getting-started-installation","text":"This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-core.git@master#egg=starlette-core The minimum Python requirement is 3.7.","title":"Getting Started - Installation"},{"location":"configuration/","text":"Configuration There are several parts of the package that require config options like email. Configuration should be stored in environment variables, or in a \".env\" file that is not committed to source control. Email These are for the smtp email backend. EMAIL_BACKEND = starlette_core.mail.backends.smtp.EmailBackend # default EMAIL_DEFAULT_FROM_ADDRESS = barry@example.com EMAIL_DEFAULT_FROM_NAME = Barry EMAIL_HOST = mail EMAIL_PORT = 537 EMAIL_USERNAME = username EMAIL_PASSWORD = password EMAIL_USE_TLS = True EMAIL_TIMEOUT = 5 If you don't want to set these as environment variables you can also define them in code. from starlette.applications import Starlette from starlette_core import config config . email_backend = ... config . email_default_from_address = ... config . email_default_from_name = ... config . email_host = ... config . email_port = ... config . email_username = ... config . email_password = ... config . email_use_tls = ... config . email_timeout = ... app = Starlette () Jinja2 Extensions These are added to the template configuration. JINJA2_EXTENSIONS = jinja2.ext.i18n, myproject.ext.foo If you don't want to set these as environment variables you can also define them in code. from starlette.applications import Starlette from starlette_core import config config . jinja2_extensions = [ \"jinja2.ext.i18n\" , \"myproject.ext.foo\" ] app = Starlette ()","title":"Configuration"},{"location":"configuration/#configuration","text":"There are several parts of the package that require config options like email. Configuration should be stored in environment variables, or in a \".env\" file that is not committed to source control.","title":"Configuration"},{"location":"configuration/#email","text":"These are for the smtp email backend. EMAIL_BACKEND = starlette_core.mail.backends.smtp.EmailBackend # default EMAIL_DEFAULT_FROM_ADDRESS = barry@example.com EMAIL_DEFAULT_FROM_NAME = Barry EMAIL_HOST = mail EMAIL_PORT = 537 EMAIL_USERNAME = username EMAIL_PASSWORD = password EMAIL_USE_TLS = True EMAIL_TIMEOUT = 5 If you don't want to set these as environment variables you can also define them in code. from starlette.applications import Starlette from starlette_core import config config . email_backend = ... config . email_default_from_address = ... config . email_default_from_name = ... config . email_host = ... config . email_port = ... config . email_username = ... config . email_password = ... config . email_use_tls = ... config . email_timeout = ... app = Starlette ()","title":"Email"},{"location":"configuration/#jinja2-extensions","text":"These are added to the template configuration. JINJA2_EXTENSIONS = jinja2.ext.i18n, myproject.ext.foo If you don't want to set these as environment variables you can also define them in code. from starlette.applications import Starlette from starlette_core import config config . jinja2_extensions = [ \"jinja2.ext.i18n\" , \"myproject.ext.foo\" ] app = Starlette ()","title":"Jinja2 Extensions"},{"location":"database/","text":"Database Within most projects there is a need for a database. Within starlette_core we use SQLAlchemy. Declarative Base Due to the fact we have created other projects that all inherit from this package such as starlette-auth there needs to be a central place that all predefined tables can inherit from a declarative base class ( see the docs ). The starlette_core.database.Base class consists of: class BaseQuery ( Query ): def get_or_404 ( self , ident ): \"\"\" performs a query.get or raises `starlette.exceptions.HTTPException` if not found. \"\"\" @as_declarative ( metadata = metadata ) class Base : @declared_attr def __tablename__ ( cls ): return cls . __name__ . lower () def __repr__ ( self ): return f \"< { self . __class__ . __name__ } , id= { self . id } >\" def __str__ ( self ): return self . __repr__ () # Default auto incrementing primary key field # overwrite as needed id = sa . Column ( sa . Integer , primary_key = True ) # Convenience property to query the database for instances of this model # using the current session. Equivalent to ``db.session.query(Model)`` query : BaseQuery def save ( self ) -> None : \"\"\" save the current instance \"\"\" def delete ( self ) -> None : \"\"\" delete the current instance \"\"\" def can_be_deleted ( self ) -> bool : \"\"\" Simple helper to check if the instance has entities that will prevent this from being deleted via a protected foreign key. \"\"\" def refresh_from_db ( self ) -> None : \"\"\" Refresh the current instance from the database \"\"\" This class should be used in all sqlalchemy tables like so: import sqlalchemy as sa from starlette_core.database import Base class User ( Base ): email = sa . Column ( sa . String ( 100 ), nullable = False , index = True , unique = True ) Methods All tables inheriting from Base will have acess to the class' functionallity. This includes .query , .save() , and .delete() . It is important that all tables(base) are imported from all packages when used: from db import database from tables import User user = User . query . first () user . email = \"user@example.com\" user . save () user . delete () Your Project Structure It's best to have a central place to keep a reference to your database. Assuming you have a db.py file in the root of your apps structure and the contents are as follows: from starlette_core.database import Database , DatabaseURL , metadata from app.settings import DATABASE_URL url = DatabaseURL ( \"sqlite:///./db.sqlite3\" ) # set engine config options engine_kwargs = {} # setup the database database = Database ( DATABASE_URL , engine_kwargs = engine_kwargs ) # once the db is initialised you can import any project # and external tables into this file. # the metadata imported above will be the complete metadata # used for your db for the likes of alembic migrations. from my_project import tables from some_other_project import tables The Database Class The starlette_core.database.Database class is what manages the connection to the database. class Database : engine = None def create_all ( self ) -> None : \"\"\" create all tables \"\"\" def drop_all ( self ) -> None : \"\"\" drop all tables \"\"\" def truncate_all ( self , force : bool = False ) -> None : \"\"\" truncate all tables \"\"\" Which when defined as above you can run commands like database.create_all() or database.engine.execute(\"SELECT .....\") on. Sessions While tables that inherit from starlette_core.database.Base will include useful helpers like save() and delete() , these internally just use a Session object ( see the docs ). This can be used directly which is particually helpful if you want to save multiple instances at the same time. from starlette_core.database import Session session = Session () instance = User ( email = \"admin@example.com\" ) try : session . add ( instance ) session . commit () except : session . rollback () Middleware Using the DatabaseMiddleware If you are using the database functionality provided by this package it is important to use the middleware to correctly handle sessions. See docs .","title":"Database"},{"location":"database/#database","text":"Within most projects there is a need for a database. Within starlette_core we use SQLAlchemy.","title":"Database"},{"location":"database/#declarative-base","text":"Due to the fact we have created other projects that all inherit from this package such as starlette-auth there needs to be a central place that all predefined tables can inherit from a declarative base class ( see the docs ). The starlette_core.database.Base class consists of: class BaseQuery ( Query ): def get_or_404 ( self , ident ): \"\"\" performs a query.get or raises `starlette.exceptions.HTTPException` if not found. \"\"\" @as_declarative ( metadata = metadata ) class Base : @declared_attr def __tablename__ ( cls ): return cls . __name__ . lower () def __repr__ ( self ): return f \"< { self . __class__ . __name__ } , id= { self . id } >\" def __str__ ( self ): return self . __repr__ () # Default auto incrementing primary key field # overwrite as needed id = sa . Column ( sa . Integer , primary_key = True ) # Convenience property to query the database for instances of this model # using the current session. Equivalent to ``db.session.query(Model)`` query : BaseQuery def save ( self ) -> None : \"\"\" save the current instance \"\"\" def delete ( self ) -> None : \"\"\" delete the current instance \"\"\" def can_be_deleted ( self ) -> bool : \"\"\" Simple helper to check if the instance has entities that will prevent this from being deleted via a protected foreign key. \"\"\" def refresh_from_db ( self ) -> None : \"\"\" Refresh the current instance from the database \"\"\" This class should be used in all sqlalchemy tables like so: import sqlalchemy as sa from starlette_core.database import Base class User ( Base ): email = sa . Column ( sa . String ( 100 ), nullable = False , index = True , unique = True )","title":"Declarative Base"},{"location":"database/#methods","text":"All tables inheriting from Base will have acess to the class' functionallity. This includes .query , .save() , and .delete() . It is important that all tables(base) are imported from all packages when used: from db import database from tables import User user = User . query . first () user . email = \"user@example.com\" user . save () user . delete ()","title":"Methods"},{"location":"database/#your-project-structure","text":"It's best to have a central place to keep a reference to your database. Assuming you have a db.py file in the root of your apps structure and the contents are as follows: from starlette_core.database import Database , DatabaseURL , metadata from app.settings import DATABASE_URL url = DatabaseURL ( \"sqlite:///./db.sqlite3\" ) # set engine config options engine_kwargs = {} # setup the database database = Database ( DATABASE_URL , engine_kwargs = engine_kwargs ) # once the db is initialised you can import any project # and external tables into this file. # the metadata imported above will be the complete metadata # used for your db for the likes of alembic migrations. from my_project import tables from some_other_project import tables","title":"Your Project Structure"},{"location":"database/#the-database-class","text":"The starlette_core.database.Database class is what manages the connection to the database. class Database : engine = None def create_all ( self ) -> None : \"\"\" create all tables \"\"\" def drop_all ( self ) -> None : \"\"\" drop all tables \"\"\" def truncate_all ( self , force : bool = False ) -> None : \"\"\" truncate all tables \"\"\" Which when defined as above you can run commands like database.create_all() or database.engine.execute(\"SELECT .....\") on.","title":"The Database Class"},{"location":"database/#sessions","text":"While tables that inherit from starlette_core.database.Base will include useful helpers like save() and delete() , these internally just use a Session object ( see the docs ). This can be used directly which is particually helpful if you want to save multiple instances at the same time. from starlette_core.database import Session session = Session () instance = User ( email = \"admin@example.com\" ) try : session . add ( instance ) session . commit () except : session . rollback ()","title":"Sessions"},{"location":"database/#middleware","text":"Using the DatabaseMiddleware If you are using the database functionality provided by this package it is important to use the middleware to correctly handle sessions. See docs .","title":"Middleware"},{"location":"email/","text":"Email Email support is provided by default. It is built to use backend strategies which are used to process the email. Sending the email The send_message takes an instance of email.message.EmailMessage . See docs. . To send an email: from email.message import EmailMessage from starlette_core.mail import send_message msg = EmailMessage () msg [ \"Subject\" ] = \"Subject\" msg [ \"From\" ] = \"From <from@example.com>\" msg [ \"To\" ] = \"To <to@example.com>\" msg . set_content ( \"\"\" Dear To, This is the email contents. Thanks. \"\"\" ) send_message ( msg ) Backends Details of the different email backends are provided below. SMTP backend The starlette_core.mail.backends.smtp.EmailBackend (which is the default). This will send an email using Python's base email modules. This does require several default configuration options. See docs . Console backend The starlette_core.mail.backends.console.EmailBackend can be used to simulate sending an email. This simply prints the contents of the email to sys.stdout . This is useful when developing locally.","title":"Email"},{"location":"email/#email","text":"Email support is provided by default. It is built to use backend strategies which are used to process the email.","title":"Email"},{"location":"email/#sending-the-email","text":"The send_message takes an instance of email.message.EmailMessage . See docs. . To send an email: from email.message import EmailMessage from starlette_core.mail import send_message msg = EmailMessage () msg [ \"Subject\" ] = \"Subject\" msg [ \"From\" ] = \"From <from@example.com>\" msg [ \"To\" ] = \"To <to@example.com>\" msg . set_content ( \"\"\" Dear To, This is the email contents. Thanks. \"\"\" ) send_message ( msg )","title":"Sending the email"},{"location":"email/#backends","text":"Details of the different email backends are provided below.","title":"Backends"},{"location":"email/#smtp-backend","text":"The starlette_core.mail.backends.smtp.EmailBackend (which is the default). This will send an email using Python's base email modules. This does require several default configuration options. See docs .","title":"SMTP backend"},{"location":"email/#console-backend","text":"The starlette_core.mail.backends.console.EmailBackend can be used to simulate sending an email. This simply prints the contents of the email to sys.stdout . This is useful when developing locally.","title":"Console backend"},{"location":"messages/","text":"Messages Quite commonly in web applications, you need to display a one-time notification message (also known as \u201cflash message\u201d) to the user after processing a form or some other type of user input. For this, Django provides full support for session-based messaging, including both anonymous and authenticated users. The messages framework allows you to temporarily store messages in one request and retrieve them for display in a subsequent request (usually the next one). Every message is tagged with a specific category (e.g., info , warning , or error ) this can be used as a class name to style the message. A message can be used in the context of a request, for example: from starlette_core.messages import message async def post ( self , request ): # handle post request message ( request , \"WooHoo You're Home\" , \"success\" ) # return the response (ie a RedirectResponse) Template function To use the get_messages() within a template, your templates will need to be loaded via our Jinja2Templates loader. See docs . < ul class = \"messages\" > {% for message in get_messages() %} < li class = \"message-{{ message.category }}\" > {{ message.message }} </ li > {% endfor %} </ ul >","title":"Messages"},{"location":"messages/#messages","text":"Quite commonly in web applications, you need to display a one-time notification message (also known as \u201cflash message\u201d) to the user after processing a form or some other type of user input. For this, Django provides full support for session-based messaging, including both anonymous and authenticated users. The messages framework allows you to temporarily store messages in one request and retrieve them for display in a subsequent request (usually the next one). Every message is tagged with a specific category (e.g., info , warning , or error ) this can be used as a class name to style the message. A message can be used in the context of a request, for example: from starlette_core.messages import message async def post ( self , request ): # handle post request message ( request , \"WooHoo You're Home\" , \"success\" ) # return the response (ie a RedirectResponse) Template function To use the get_messages() within a template, your templates will need to be loaded via our Jinja2Templates loader. See docs . < ul class = \"messages\" > {% for message in get_messages() %} < li class = \"message-{{ message.category }}\" > {{ message.message }} </ li > {% endfor %} </ ul >","title":"Messages"},{"location":"middleware/","text":"Middleware There are some useful middleware included that you can use as described below. DatabaseMiddleware Because we use sessions in starlette-core, by default Sessions are defined globally. This means when you do a Session.commit() or Session.rollback() this can bleed accross active requests. This middleware provides a scopefunc to the Session that isolates the session to a single request. See docs . Using the DatabaseMiddleware If you are using the database functionality provided by this package it is important to use this middleware. See docs . Enable the middleware: from starlette_core.middleware import DatabaseMiddleware app . add_middleware ( DatabaseMiddleware ) CurrentRequestMiddleware This middleware provides a useful function to get the current request object. This enables modules to access the things like the current logged in user outside of the view/endpoint. Enable the middleware: from starlette_core.middleware import CurrentRequestMiddleware app . add_middleware ( CurrentRequestMiddleware ) Access the request object: from starlette_core.middleware import get_request request = get_request () if request : user = request . get ( \"user\" )","title":"Middleware"},{"location":"middleware/#middleware","text":"There are some useful middleware included that you can use as described below.","title":"Middleware"},{"location":"middleware/#databasemiddleware","text":"Because we use sessions in starlette-core, by default Sessions are defined globally. This means when you do a Session.commit() or Session.rollback() this can bleed accross active requests. This middleware provides a scopefunc to the Session that isolates the session to a single request. See docs . Using the DatabaseMiddleware If you are using the database functionality provided by this package it is important to use this middleware. See docs . Enable the middleware: from starlette_core.middleware import DatabaseMiddleware app . add_middleware ( DatabaseMiddleware )","title":"DatabaseMiddleware"},{"location":"middleware/#currentrequestmiddleware","text":"This middleware provides a useful function to get the current request object. This enables modules to access the things like the current logged in user outside of the view/endpoint. Enable the middleware: from starlette_core.middleware import CurrentRequestMiddleware app . add_middleware ( CurrentRequestMiddleware ) Access the request object: from starlette_core.middleware import get_request request = get_request () if request : user = request . get ( \"user\" )","title":"CurrentRequestMiddleware"},{"location":"pagination/","text":"Pagination With starlette-core we include a global Paginator class for the project. This will support splitting data across multiple pages, auto-generating page numbers and calling a page via it's numerator. Allowing the use of \u201cPrevious/Next\u201d links in a template. By passing Paginator a list of objects, plus the number of items you\u2019d like to have on each page, it provides you with methods for accessing the items for each page: from starlette_core.paginator import Paginator # paginate objects with 25 items per page paginator = Paginator ( objects , 25 ) # total records in all pages paginator . count # total pages in paginator paginator . num_pages # get page 1 page = paginator . page ( 1 ) # get the list of objects in that page page . object_list # get the page number page . number # are there any other pages page . has_other_pages # is there a previous page page . has_previous # get previous page number page . previous_page_number # is there a next page page . has_previous # get next page number page . next_page_number Template Implementation We pass Paginator into a template using the request method. This example assumes you have a Users model that has already been imported: from starlette_core.paginator import Paginator async def listing ( request ): user_list = Users . objects . all () paginator = Paginator ( user_list , 25 ) # Show 25 contacts per page page_number = request . query_params . get ( \"page\" , 1 ) page = paginator . get_page ( page_number ) template = \"list.html\" context = { \"request\" : request , \"paginator\" : paginator , \"page\" : page } return templates . TemplateResponse ( template , context ) In the template you will want to be able to navigate between pages. This can be achieved by referencing paginator and page : < div > {% if page.has_previous %} < a class = \"button\" href = \"?page=1\" > First </ a > < a class = \"button\" href = \"?page={{ page.previous_page_number }}\" > Previous </ a > {% endif %} </ div > < div > Page {{ page.number }} of {{ paginator.num_pages }} - {{ paginator.count }} record{% if paginator.count != 1 %}s{% endif %} </ div > < div > {% if page.has_next %} < a class = \"button\" href = \"?page={{ page.next_page_number }}\" > Next </ a > < a class = \"button\" href = \"?page={{ paginator.num_pages }}\" > Last </ a > {% endif %} </ div >","title":"Pagination"},{"location":"pagination/#pagination","text":"With starlette-core we include a global Paginator class for the project. This will support splitting data across multiple pages, auto-generating page numbers and calling a page via it's numerator. Allowing the use of \u201cPrevious/Next\u201d links in a template. By passing Paginator a list of objects, plus the number of items you\u2019d like to have on each page, it provides you with methods for accessing the items for each page: from starlette_core.paginator import Paginator # paginate objects with 25 items per page paginator = Paginator ( objects , 25 ) # total records in all pages paginator . count # total pages in paginator paginator . num_pages # get page 1 page = paginator . page ( 1 ) # get the list of objects in that page page . object_list # get the page number page . number # are there any other pages page . has_other_pages # is there a previous page page . has_previous # get previous page number page . previous_page_number # is there a next page page . has_previous # get next page number page . next_page_number","title":"Pagination"},{"location":"pagination/#template-implementation","text":"We pass Paginator into a template using the request method. This example assumes you have a Users model that has already been imported: from starlette_core.paginator import Paginator async def listing ( request ): user_list = Users . objects . all () paginator = Paginator ( user_list , 25 ) # Show 25 contacts per page page_number = request . query_params . get ( \"page\" , 1 ) page = paginator . get_page ( page_number ) template = \"list.html\" context = { \"request\" : request , \"paginator\" : paginator , \"page\" : page } return templates . TemplateResponse ( template , context ) In the template you will want to be able to navigate between pages. This can be achieved by referencing paginator and page : < div > {% if page.has_previous %} < a class = \"button\" href = \"?page=1\" > First </ a > < a class = \"button\" href = \"?page={{ page.previous_page_number }}\" > Previous </ a > {% endif %} </ div > < div > Page {{ page.number }} of {{ paginator.num_pages }} - {{ paginator.count }} record{% if paginator.count != 1 %}s{% endif %} </ div > < div > {% if page.has_next %} < a class = \"button\" href = \"?page={{ page.next_page_number }}\" > Next </ a > < a class = \"button\" href = \"?page={{ paginator.num_pages }}\" > Last </ a > {% endif %} </ div >","title":"Template Implementation"},{"location":"templating/","text":"Templating At the time of publication, Starlette's templates only supports passing in a directory to load templates from. Since we have multiple repos that can all include their own templates, we have provided a modified version which takes in a Jinja2 loader as its argument. This allows for more complex scenarios such as referencing multiple directories and those outside of the current project, for example: import jinja2 from starlette_core.templating import Jinja2Templates templates = Jinja2Templates ( loader = jinja2 . ChoiceLoader ( [ jinja2 . FileSystemLoader ( \"templates\" ), jinja2 . PackageLoader ( \"starlette_admin\" , \"templates\" ), ] ) ) async def home ( request ): template = \"home.html\" context = { \"request\" : request } return templates . TemplateResponse ( template , context ) Jinja2 Extensions Extensions can be added by providing configuration to this package. See docs .","title":"Templating"},{"location":"templating/#templating","text":"At the time of publication, Starlette's templates only supports passing in a directory to load templates from. Since we have multiple repos that can all include their own templates, we have provided a modified version which takes in a Jinja2 loader as its argument. This allows for more complex scenarios such as referencing multiple directories and those outside of the current project, for example: import jinja2 from starlette_core.templating import Jinja2Templates templates = Jinja2Templates ( loader = jinja2 . ChoiceLoader ( [ jinja2 . FileSystemLoader ( \"templates\" ), jinja2 . PackageLoader ( \"starlette_admin\" , \"templates\" ), ] ) ) async def home ( request ): template = \"home.html\" context = { \"request\" : request } return templates . TemplateResponse ( template , context )","title":"Templating"},{"location":"templating/#jinja2-extensions","text":"Extensions can be added by providing configuration to this package. See docs .","title":"Jinja2 Extensions"},{"location":"testing/","text":"Testing Within the starlette_core package there is a set of helpers to aid testing your project. SQLAlchemy fields Assuming you have the following SQLAlchemy model to test: import sqlalchemy as sa from starlette_core.database import Base class User ( Base ): email = sa . Column ( sa . String ( 100 ), nullable = False , index = True , unique = True ) There is a function to test fields on a model: def assert_model_field ( cls : typing . Type [ Base ], name : str , type : typing . Any , nullable : bool = True , index : bool = False , unique : bool = False , length : int = None , ): ... This can be used like so to test each field: from starlette_core.testing import assert_model_field def test_email (): assert_model_field ( User , \"email\" , sa . String , False , True , True , 255 )","title":"Testing"},{"location":"testing/#testing","text":"Within the starlette_core package there is a set of helpers to aid testing your project.","title":"Testing"},{"location":"testing/#sqlalchemy-fields","text":"Assuming you have the following SQLAlchemy model to test: import sqlalchemy as sa from starlette_core.database import Base class User ( Base ): email = sa . Column ( sa . String ( 100 ), nullable = False , index = True , unique = True ) There is a function to test fields on a model: def assert_model_field ( cls : typing . Type [ Base ], name : str , type : typing . Any , nullable : bool = True , index : bool = False , unique : bool = False , length : int = None , ): ... This can be used like so to test each field: from starlette_core.testing import assert_model_field def test_email (): assert_model_field ( User , \"email\" , sa . String , False , True , True , 255 )","title":"SQLAlchemy fields"}]}